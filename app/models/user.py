from werkzeug.security import check_password_hash
from werkzeug.security import generate_password_hash
from sqlalchemy import func

from datetime import datetime
from datetime import timedelta
import uuid
import secrets
import time

from app import db

class BaseMixin(object):
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    created = db.Column(db.DateTime, nullable=False, default=datetime.now())
    modified = db.Column(db.DateTime, nullable=False, default=datetime.now(), onupdate=datetime.now())
    deleted = db.Column(db.DateTime, nullable=True)


class User(BaseMixin, db.Model):
    __tablename__ = 'users'


    #short unique identifier (generated by default)
    uid = db.Column(db.String(64), index=True, unique=True, nullable=False)
   
    #unique email for login
    email = db.Column(db.String(128), nullable=False, unique=True, index=True)

    #hash using sha256
    password = db.Column(db.String(128), nullable=False)

    first_name = db.Column(db.String(128), nullable=False)
    last_name = db.Column(db.String(128), nullable=False)

    #1 - administrator
    #2 - finance manager
    #3 - manager
    #4 - employee
    role = db.Column(db.Integer, default=4, nullable=False)

    #0 - deactivated
    #1 - activated
    #2 - blocked
    status = db.Column(db.Integer, default=0, nullable=False)

    @classmethod
    def create_user(cls, **kw):
        #assumed kw is a clean user details
        try:
            obj = cls(**kw)
            db.session.add(obj)
            db.session.commit()

            return True
        except:
            db.session.rollback()
            return False


    @classmethod
    def update_user_by_id(cls, id, **kw):
        obj = cls.query.filter(cls.id==id).first()
        if obj is None:
            return False
        
        obj.email = kw.get('email')
        obj.first_name = kw.get('first_name')
        obj.last_name = kw.get('last_name')
        obj.last_name = kw.get('last_name')
        obj.role = kw.get('role')
        db.session.commit()
        return True

    @classmethod
    def update_user_by_uid(cls, uid, **kw):
        obj = cls.query.filter(cls.uid==uid).first()
        if obj is None:
            return False
        
        obj.email = kw.get('email')
        obj.first_name = kw.get('first_name')
        obj.last_name = kw.get('last_name')
        obj.last_name = kw.get('last_name')
        obj.role = kw.get('role')
        db.session.commit()
        return True


    @classmethod
    def update_user_password_by_id(cls, id, password):
        obj = cls.query.filter(cls.id==id).first()
        if obj is None:
            return False
        
        obj.password = password
        db.session.commit()
        return True


    @classmethod
    def update_user_password_by_uid(cls, uid, password):
        obj = cls.query.filter(cls.uid==uid).first()
        if obj is None:
            return False
        
        obj.password = password
        db.session.commit()
        return True


    @classmethod
    def find_by_id(cls, id):
        q = cls.query.filter(cls.id==id).first()
        
        if q is not None:
            return q

        return None

    
    @classmethod
    def find_by_uid(cls, uid):
        q = cls.query.filter(cls.uid==uid).first()
        
        if q is not None:
            return q

        return None

    
    @classmethod
    def find_by_role(cls, role):
        q = cls.query.filter(cls.role==role).all()
        
        if q is not None:
            return q

        return None

    
    @classmethod
    def get_all(cls):
        q = cls.query.all()
        
        if q is not None:
            return q

        return None

    
    @classmethod
    def is_existing_email(cls, email):
        q = cls.query.filter(cls.email==email).first()
        
        if q is None:
            return False

        return True

    
    @classmethod
    def is_existing_email_for_update_by_uid(cls, uid, email):
        q = cls.query.filter(cls.uid!=uid, cls.email==email).first()
        
        if q is None:
            return False

        return True

    
    @classmethod
    def is_existing_email_for_update_by_id(cls, id, email):
        q = cls.query.filter(cls.id!=id, cls.email==email).first()
        
        if q is None:
            return False

        return True

    
    @classmethod
    def is_valid_user(cls, email, password):
        q = cls.query.filter(cls.email==email).first()
        
        if q is not None:
            if not check_password_hash(q.password, password):
                return None

            return q

        return None

    
    @classmethod
    def generate_uid(cls):
        uid = None

        while uid is None:
            uid = str(uuid.uuid4())

            if cls.query.filter(cls.uid==uid).first() is not None:
                uid = None

        return uid


    def generate_password(password):
        return generate_password_hash(password, "sha256") 


    @property
    def is_admin(self):
        return self.role == 1


    @property
    def is_finance_manager(self):
        return self.role == 2


    @property
    def is_manager(self):
        return self.role == 3


    @property
    def is_employee(self):
        return self.role == 4


    @property
    def is_activated(self):
        return self.status == 1


class UserToken(BaseMixin, db.Model):
    __tablename__ = 'user_tokens'

    expiration = db.Column(db.DateTime, nullable=False, default=datetime.now() + timedelta(days=7))

    token = db.Column(db.String(256), index=True, nullable=False)

    user = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)

    #1 - active
    #2 - expired
    #3 - blocked
    status = db.Column(db.Integer, nullable=False, default=1)

    
    @classmethod
    def create_token(cls, **kw):
        #assumed kw is a clean user details
        try:
            obj = cls(**kw)
            db.session.add(obj)
            db.session.commit()

            return True
        except:
            db.session.rollback()
            return False


    @classmethod
    def generate_token(cls):
        token = None

        while token is None:
            token = '{time}{secret}'.format(time=str(time.time()).replace('.', ''), secret=secrets.token_hex(64))

            if cls.query.filter(cls.token==token).first() is not None:
                token = None

        return token


    @classmethod
    def is_valid_token(cls, token):
        q = cls.query.filter(cls.token==token).first()

        if q is not None:
            return q

        return None

    
    @classmethod
    def block_token(cls, token):
        q = cls.query.filter(cls.token==token).first()
        
        try:
            q.status = 3
            db.session.commit()
        except:
            db.session.rollback()

    
    @classmethod
    def expire_token(cls, token):
        q = cls.query.filter(cls.token==token).first()
        
        try:
            q.status = 2
            db.session.commit()
        except:
            db.session.rollback()

    
    @property
    def is_active(self):
        return self.status == 1


    @property 
    def is_expired(self):
        remaining_seconds =  (self.expiration - datetime.now()).total_seconds()
        return remaining_seconds < 0 or self.status == 2


    @property
    def is_blocked(self):
        return self.status == 3


